// TODO these projects are still disorganized, should be refractored in even more modules

const axios = require('axios');
const actions = require('@json/actions.json');
const memes = require('@json/memes.json');

const { Sleep } = require("@lib/sleep.js");
const { 
    formatter,
    getLectures,
    replyWithLecture,
    message,
    settings,
    start,
} = require('@lib/utils.js');

const {
    replyAfterPromises,
    getPromises,
    getGroup,
    removeFromGroup
} = require("@lib/groupUtils.js")

if (process.argv.length != 2) {
	console.log('usage: [API_KEY env-var] node index.js');
}
process.env.NTBA_FIX_319 = 1;

function messageLectures(msg, url, fallbackText, isTomorrow) {
	axios.get(url)
	.then(res => {
		const lectures = getLectures(res, isTomorrow=isTomorrow);
		replyWithLecture(msg, lectures, fallbackText);
	})
	.catch(e => console.error(e.stack));
}

// Autogenerated courses info
function course(msg, courseObject) {
    // TODO, assert that the object is well formed, check that virtuale, teams, website are strings
    // and professors is a list
	const emails = courseObject.professors.join('@unibo.it\n  ') + '@unibo.it';
	message(msg, `<b>${courseObject.name}</b>
	<a href='https://virtuale.unibo.it/course/view.php?id=${courseObject.virtuale}'>Virtuale</a>
	<a href='https://teams.microsoft.com/l/meetup-join/19%3ameeting_${courseObject.teams}%40thread.v2/0?context=%7b%22Tid%22%3a%22e99647dc-1b08-454a-bf8c-699181b389ab%22%2c%22Oid%22%3a%22080683d2-51aa-4842-aa73-291a43203f71%22%7d'>Videolezione</a>
	<a href='https://www.unibo.it/it/didattica/insegnamenti/insegnamento/${courseObject.website}'>Sito</a>
	<a href='https://www.unibo.it/it/didattica/insegnamenti/insegnamento/${courseObject.website}/orariolezioni'>Orario</a>
	${emails}`);
}

// Adding a user to a list
function lookingFor(msg, singularText, pluralText, chatError) {
	if (msg.chat.type !== 'group' && msg.chat.type !== 'supergroup' || settings.lookingForBlackList.includes(msg.chat.id)) {
		message(msg, chatError);
        return
    } 
    const group = getGroup(msg.chat.id, msg.from.id);

    // design-issue: metto sti field in msg perché è più facile da passere in funzione
    // ma non so se è una best-practice, forse c'è un design migliore
    msg.singularText = singularText;
    msg.pluralText = pluralText;

    const promises = getPromises(group, msg.chat.id);
    replyAfterPromises(msg, promises, group);
}

// Removing a user from a list
function notLookingFor(msg, text, chatError, notFoundError) {
	if (msg.chat.type !== 'group' && msg.chat.type !== 'supergroup' || settings.lookingForBlackList.includes(msg.chat.id)) {
		message(msg, chatError);
        return;
    }
    const response = removeFromGroup(msg, notFoundError);
    if (response.status === 404) {
        return;
    }
    message(msg, formatter(text, msg.chat.title));
    return;
}

const giveHelp = (msg) => {
	answer = "";
    courses = "";
	for (command in actions) {
        if (actions[command].description === undefined) {
            continue;
        }
        if (actions[command].type === "course") {
            courses += `/${command}\n`
            continue;
        }

        try {
            answer += `/${command}: ${actions[command].description}\n`
        } catch(e) {
            console.error(e);
            console.log("Malformed action JSON");
        }
	}

    // rendering speciale per i corsi
    answer += "\n<b>I corsi attivi: </b>\n";
    answer += courses;
	message(msg, answer);
}

// Available actions
const act = (msg, action) => {
	switch (action.type) {
		case 'course':
			course(msg, action);
			break;
		case 'lookingFor':
			lookingFor(msg, action.singularText, action.pluralText, action.chatError);
			break;
		case 'message':
			message(msg, action.text);
			break;
		case 'notLookingFor':
			notLookingFor(msg, action.text, action.chatError, action.notFoundError);
			break;
		case 'todayLesson':
			messageLectures(msg, action.url, action.fallbackText, isTomorrow=false);
			break;
        case 'tomorrowLesson':
            messageLectures(msg, action.url, action.fallbackText, isTomorrow=true);
            break;
		case 'help':
			giveHelp(msg);
			break;
        case "toggleSleep":
            Sleep.toggle(msg);
			break;
		default:
			console.error(`Unknown action type "${action.type}"`);
	}
}

const onMessage = (msg) => {
    if (!msg.text || msg.text.toString()[0] != '/') {
        return;
    }
	Sleep.receive(msg);

    const text = msg.text.toString()
    // '/command@bot param0 ... paramN' -> 'command'
    command = text.toLowerCase().split(' ')[0].substring(1);
    if (command.includes('@')) {
        command = command.substring(0, command.indexOf('@'));
    }
    if (command in actions) {
        act(msg, actions[command]);
    } else if (command in memes) {
        message(msg, memes[command]);
    }
}


function main() {
    start(onMessage);
}

module.exports = {
    main: main
}
