// Dynamic path requiring https://gist.github.com/branneman/8048520
require('module-alias/register');
const axios = require('axios');
const actions = require('@json/actions.json');
const memes = require('@json/memes.json');
const { 
    formatter,
    getLectures,
    replyWithLecture,
    message,
    settings,
    start
} = require('@lib/utils.js');

const {
    replyAfterPromises,
    getPromises,
    getGroup,
    removeFromGroup
} = require("@lib/groupUtils.js")

if (process.argv.length != 2) {
	console.log('usage: [API_KEY env-var] node index.js');
}
process.env.NTBA_FIX_319 = 1;

function todayLectures(msg, url, fallbackText) {
	axios.get(url)
	.then(res => {
		const todayLectures = getLectures(res, isTomorrow=false);
		replyWithLecture(msg, todayLectures, fallbackText);
	})
	.catch(e => console.error(e.stack));
}

function tomorrowLectures(msg, url, fallbackText) {
	axios.get(url)
	.then(res => {
		const tomorrowLectures = getLectures(res, isTomorrow=true);
		replyWithLecture(msg, tomorrowLectures, fallbackText);
	})
	.catch(e => console.error(e.stack));
}

// Autogenerated courses info
function course(msg, courseObject) {
    // TODO, assert that the object is well formed, check that virtuale, teams, website are strings
    // and professors is a list
	const emails = courseObject.professors.join('@unibo.it\n  ') + '@unibo.it';
	message(msg, `<b>${courseObject.name}</b>
	<a href='https://virtuale.unibo.it/course/view.php?id=${courseObject.virtuale}'>Virtuale</a>
	<a href='https://teams.microsoft.com/l/meetup-join/19%3ameeting_${courseObject.teams}%40thread.v2/0?context=%7b%22Tid%22%3a%22e99647dc-1b08-454a-bf8c-699181b389ab%22%2c%22Oid%22%3a%22080683d2-51aa-4842-aa73-291a43203f71%22%7d'>Videolezione</a>
	<a href='https://www.unibo.it/it/didattica/insegnamenti/insegnamento/${courseObject.website}'>Sito</a>
	<a href='https://www.unibo.it/it/didattica/insegnamenti/insegnamento/${courseObject.website}/orariolezioni'>Orario</a>
	${emails}`);
}

// Adding a user to a list
function lookingFor(msg, singularText, pluralText, chatError) {
	if (msg.chat.type !== 'group' && msg.chat.type !== 'supergroup' || settings.lookingForBlackList.includes(msg.chat.id)) {
		message(msg, chatError);
        return
    } 
    const group = getGroup(msg.chat.id, msg.from.id);

    // design-issue: metto sti field in msg perché è più facile da passere in funzione
    // ma non so se è una best-practice, forse c'è un design migliore
    msg.singularText = singularText;
    msg.pluralText = pluralText;

    const promises = getPromises(group, msg.chat.id);
    replyAfterPromises(msg, promises, group);
}

// Removing a user from a list
function notLookingFor(msg, text, chatError, notFoundError) {
	if (msg.chat.type !== 'group' && msg.chat.type !== 'supergroup' || settings.lookingForBlackList.includes(msg.chat.id)) {
		message(msg, chatError);
        return;
    }
    const response = removeFromGroup(msg, notFoundError);
    if (response.status === 404) {
        return;
    }
    message(msg, formatter(text, msg.chat.title));
    return;
}

const giveHelp = (msg) => {
	answer = ""
	for (command in actions) {
		try {
			answer += `/${command}: ${actions[command]["description"]}\n`
		} catch(e) {
			continue;
			// Debugging: 
			// message(msg, `Ho avuto questo errore, debuggame ${e}`)
		}
	}
	message(msg, answer);
}

// Available actions
const act = (msg, action) => {
	switch (action.type) {
		case 'alias':
			act(msg, actions[action.command]);
			break;
		case 'course':
			course(msg, action);
			break;
		case 'lookingFor':
			lookingFor(msg, action.singularText, action.pluralText, action.chatError);
			break;
		case 'message':
			message(msg, action.text);
			break;
		case 'notLookingFor':
			notLookingFor(msg, action.text, action.chatError, action.notFoundError);
			break;
		case 'todayLesson':
			todayLectures(msg, action.url, action.fallbackText);
			break;
        case 'tomorrowLesson':
            tomorrowLectures(msg, action.url, action.fallbackText);
            break;
		case 'help':
			giveHelp(msg);
			break;
		default:
			console.error(`Unknown action type "${action.type}"`);
	}
}

const onMessage = (msg) => {
    if (!msg.text || msg.text.toString()[0] != '/') {
        return;
    }
    const text = msg.text.toString()
    // '/command@bot param0 ... paramN' -> 'command'
    command = text.toLowerCase().split(' ')[0].substring(1);
    if (command.includes('@')) {
        command = command.substring(0, command.indexOf('@'));
    }
    if (command in actions) {
        act(msg, actions[command]);
    } else if (command in memes) {
        message(msg, memes[command]);
    }
}

function main() {
    start(onMessage);
}
main();


// Using express so heroku doesn't complain about not using web
const express = require('express')();

express.get('/', (req, res) => {
	res.send('This is a Telegram bot working.')
})

express.listen(process.env.PORT || 3000, () => {
	console.log(`Example app listening at http://localhost:${process.env.PORT || 3000}`)
})

